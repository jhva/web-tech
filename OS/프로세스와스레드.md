
# 프로세스와 스레드 
## 프로세스
> 프로세스는 메모리 상에서 실행중인 작업을 말하고 스레드는 프로세스 안에서 실행되는 여러 흐름의 단위이다 
> 

위에서 말하는 실행중인 것은 우리가 일상생활에서 .exe파일이던지, 여러 응용프로그램들을 실행하면 메모리 상에 올라가면서 우리 눈에 보이지않는 추상적인 표현으로 명칭한 것이 프로세스이다.<br/>

이러한 프로세스 안에 가상의 메모리, 최소 1개의 여러 흐름의 단위(스레드)가 존재한다. <br/>

이러한 프로세스는 CPU 로 부터 자원을 할당받고 수행합니다.또한 프로세스는 독립적으로 수행되기때문에 하나의 프로세스에서 오류가 생기더라도 다른 프로세스에게 영향을 주지않습니다. <br/>

이렇듯 독립적인 영역을 갖기 때문에 Context Switching 비용이 크며, 별다른 동기화 
작업이 필요하지 않는다.

### 컨텍스트 스위칭 - Context Switching
> <b>Context Switching</b> 은 CPU 가 작업중인 프로세스/스레드에서 다른 프로세스/스레드로 넘어갈시 이전 프로세스 내용을 PCB 에 저장하고 새로 실행될 프로세스의 정보를 PCB 에서 읽어서 레지스터에 적재되는현상을 말한다 .
>
<strong>Context Switching </strong> 프로세스/스레드 혹은 다른프로세스에서의 스레드 로 교체하기위해서 위해서이다.<br/>

그 이유는 프로세스는 한번에 하나의 프로세스만 수행 할 수 있는데 여러 프로세스 및 스레드를 동시에 실행시키기위해선 컨텍스트 스위칭이 필요하다. 

컨텍스트 스위칭은 OS 커널에 의해서 실행이되며, CPU 스케줄링에 의해 할당된 작업시간이 끝났을시점 또는 실행 중이던 프로세스가 I/O 작업시 발생된다.

이러한 이유로 멀티프로세스/멀티스레드가 존재한다. 
<details>
<summary>
 컨텍스트 스위칭 발생시점 
</summary>
<div markdown="1">

- 멀티태스킹
  - 운영체에의 스케줄러에 의해 조금씩 번갈아갈때 수행됨 .
- 인터럽트 핸들링
  - 컴퓨터 시스템에서 예외 상황이 발생했을때 컨텍스트 스위칭 함 
  - I/O 요청
  - CPU 사용시간이 만료 
  - 자식 프로세스 생성 
  - 인터럽트 처리 대기
- 사용자와 커널 모드 전환 

#### 컨텍스트 스위칭 처리 과정
> Process A,Process B
1. A가 실행할때 인터럽트, 혹은 시스템 콜 발생
2. PCB에 A의 대한 정보 저장 PCB2의 상태 불러옴
3. B 실행
4. B 실행시 인터럽트 or 시스템 콜 발생
5. PCB2 에 B 정보 저장 , PCB1의 상태 불러옴
6. A를 다시 실행

_이렇게 계속 프로세스가 바뀌는과정을 컨텍스트 스위칭이라고 하며 이 과정에서 프로세스가 실행되기 전까지의 기다리는시간,메모리 등을 오버헤드라고 부른다 하지만 이러한 시간을 소비하는 동안 I/O작업같은경우엔 비교적 시간소모가 더 크기때문에 컨텍스트스위칭하는것이 효율적_
### PCB
> <strong>PCB</strong> 는 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳이며 프로세스의 상태가 정보가 저장이 되어있으며, 프로세스가 생성될때마다 고유 PCB 가 생성되고,프로세스가 생성이 완료되면 PCB 는 제거된다.

_PCB는 여러 프로세스를 효과적으로 관리하고 스케줄링하기 위한 자료 구조인데. PCB 에는 각 프로세스의 상태, 레지스터 값, 프로그램 카운터 등의 정보가 저장된다._ <br/>

_이 정보를 활용하여 여러 프로세스가 동시에 실행되는 것처럼 느끼게 하는데, 이것이 멀티태스킹 또는 타임쉐어링이다._


#### PCB 구조
1. Process Id
    1. 프로세스 고유 번호
2. Process state
    1. 프로세스 상태(생성,준비,실행,대기,완료)
        1. new: 프로세스 생성되고 시작
        2. running: 프로세스가 동작 중인 상태며 명령어 로딩해서 CPU 적재
        3. waiting: 프로세스 A이 프로세스 B가 동작하는동안 기다리고 있는 상태
        4. Ready: 프로세스가 Ready Queue에 들어가서 차례를 기다리고 있는 상태
        5. Terminated: 모든 걸 끝낸 프로세스 상태
3. Program counter
    1. 프로세스가 다음 실행할 명령어 주소
4. Register info
    1. 가장 작은 단위의 임시 메모리 저장 공간 ,CPU 레지스터 값
5. Scheduling info
    1. CPU 스케줄링 우선순위
6. Memory related info
    1. 메모리가 할당된 자원의 정보
7. Accounting info
    1. 최초 실행 시각, CPU 점유 시간,데이터
8. Status info related to I/O
    1. 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록

</div>
</details>

 

## 프로세스의 메모리 구조 
> Code,Data,Heap,Stack,PCB

### Code 영역 
> 기계어 명령 형태로 저장되는 공간 
> 
코드 영역은 코드 자체를 구성하는 메모리 영역이다. 여기서 CPU가 수행할 수 있는 형태로 변환되어서 중간에 코드를 바꿀 수 없게 ReadOnly로 되어있으며 , 프로그램이 종료 될 때 까지 메모리에 계속 남아있음.
### Data 영역
> 프로그램이 사용하는 데이터를 저장하는 공간이며 크게 도 Data 영역, BSS 영역으로 나뉠수 있다.
> 
전역 변수, static 변수 등 데이터를 저장하는 공간이다. 이를 참조한 코드는 컴파일이완료되면 Data 영역의 주소 값을 가리키도록 변경되고 전역변수 같은 경우엔 변경 될 여지가 있으므로 Read-Writer 로 되어 있다.

전역변수나 static 변수가 초기값이 있을경우엔 Data 영역 
초기값이 없으면 BSS 영역으로 할당. 

프로그램이 사작할때 함께 할당되고 프로그램이 종료되면 소멸함 .

### Heap 영역
> 필요할때마다 사용하는 메모리 영역이며 런타임시 크기가 결정 되며,메모리 제한이 없으며 힙영역은 사용자가 직접 관리 및 해제를 해야한다 . 
> 
힙 영역은 필요에 의해 동적으로 메모리를 할당 할때 위치하는 메모리 영역이다. 메모리 주소 값에 의해서만 참조되고 사용되는 영역이다. 

여기서 동적으로 할당하는 것은 프로그램이 실행될때 메모리 공간을 할당하는 것을 말한다. 동적으로 할당되는 부분들은 힙 영역에 생기게된다.

힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 해제된다.
ex) <b>new, int a = new int[]; </b> 등등 .. 

추후 작성하게 될 JVM 가비지컬렉터(GC)에 대해서 공부하면 될 것 같다. GC는 잠깐 간단하게말하면  힙 영역에 생성되는 <b> new 로 생성된 인스턴스,배열</b> 등등 이 있는데 생성된 객체들의 참조가 없을 경우 알아서 GC를 통해 객체를 해제해주고 메모리 관리를 해준다.

### Stack 영역
> 함수 호출 시 생성되는 지역 변수, 매개 변수가 저장되는 영역이며,CPU 가 직접 관리하고 컴파일시 크기가 결졍된다. 
>
라이플사이클같은경우엔 함수 호출 시 생성되고, 함수 종료시 반환되며 

메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다. <br/>



힙공간과 스택공간은 서로 낮은 주소에서 높은주소로할당되고 , 스택공간은 높은주소에서 낮은주소로 할당되는데 이때 각각의 영역을 침범할 경우 발생되는 것이 <b/>(힙이 스택 영역에 침범)Heap Overflow </b> , <b>(스택이 힙 영역에 침범)Stack 
Overflow</b>이다. 

## Thread - 스레드
> 프로세스 내의 실행 단위이다. 스레드는 프로세스가 생성될때 최소 1개의 스레드가 생성된다.
>
각 스레드는 stack 영역,레지스터 값 갖으며, 나머지 영역(heap,data,code)은 해당 프로세스내의 스레드끼리 자원을 공유한다.
<details>
<summary>왜 스레드는 stack 을 독립적으로 갖게될까 ?</summary>
<div markdown="4">

- 스택은 하나의 함수가 실행될때 함수가 끝나고 돌아가야할 주소값, <br/>
해당 함수내에서 선언한 변수 값들을 저장하고 나가며 이러한 방식에 의해 독립적인 함수 호출이 가능해지기 때문에 독립적인 작업실행도 된다는 의미이다 .
  
- 스레드가 외부 영역의 자원을 공유하기위해선 동기화 작업이 필요함.
</div>
</details>

<details>
<summary>왜 레지스터값을 독립적으로 갖게될까 ?</summary>
<div markdown="2">

- 이유는 스레드가 CPU 스케줄러에의해 실행 순서가 바뀌게되는데 이러한 실행 순서를 기억해놓기위해서.
</div>
</details>

<details>
<summary><span>프로세스 와 스레드 차이</span> </summary>
<div markdown="3">

- 프로세스는 한 프로그램의 실행 작업 단위이며, 스레드는 프로세스안에서의 실행흐름 단위이다. <br/>또한 위에서 설명한 것처럼 각각의 프로세스는 독립적이기때문에 하나의 프로세스가 죽었다고 <br/>한들.
다른 프로세스의 영향은 없습니다.<br/> 
- 하지만 하나의 프로세스안에서 1개이상의 
  스레드가 존재할시 하나의 스레드가 죽거나하게되면 이경우 같은 프로세스 내의 모든 스레드가 종료가된다. 또한 (data,code,heap) 영역을 공유하고있기때문에 여기서 동기화 문제가 발생할수있습니다.
</div>
</details>


# 멀티프로세스 와 멀티스레드 

## 멀티 프로세스
> 운영체제 위에서 하나의 응용 프로그램이 동시에 여러 개의 프로세스를 실행을 할 수 있게 해주는 기술
>
멀티 프로세스는 여러 프로세스가 작업을 병렬처리를 하는 것을 의미한다. 여러 프로세스가 작업을 같이 하고있기때문에 하나의 프로세스가 죽는다 해도 문제가 되진 않는다.<br/>

하지만 프로세스 끼리는 공유하는 메모리가 없어서 컨텍스트 스위칭이 비용이 발생하게 되며 RAM과 CPU 사이의 캐쉬 메모리도 초기화 되서 오버헤드가 크다 . 또한 생성될때마다 PCB,데이터 구조 등등 계속해서 생성되는 자체가 OS 메모리자체의 부담이 갈 가능성이 크다고 생각한다. 

## 멀티 스레드
> 하나의 프로세스안에서 여러개의 스레드가 존재하는 것을 말한다. 따라서 어떠한 프로그램을 실행 했을때 여러개 동작(함수) 등을 동시에 실행 할 수 있는것. 
> 
스레드 자체는 프로세스의 (code,data,heap)영역에서 공유 하고 있어서, 컨텍스트 스위칭이 발생하지않는다. 스레드는 스택영역만 초기화시기면 되기때문이다.<br/>

때문에 스레드 간의 통신의 응답이 멀티 프로세스 보다 빠르다. 

이러한 이점이 있지만 단점으로는 하나의 프로세스에서 멀티 스레드일경우 하나의 스레드가 문제가 생기면 프로세스는 종료됩니다. 왜냐면 자원을 공유하고 있기때문에 <strong><a href="">동기화 문제</a></strong>가 발생합니다. 

