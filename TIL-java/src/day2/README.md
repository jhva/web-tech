## Call by value, Call by reference 
### 매개변수 
> 매개변수로 전달되는 데이터가 기본형인지, 참조형인지, 에 따라 동작 방식이달라진다. 
- 예시 
```
int score= 90; 

int copyScore=score; 
```
- 이렇게해도 두개의 변수가 동일한 값을 가진다. 
  - why? 
    - copyScore는 score주소값을 가리키고있기때문에 

### call by value
 - 매개변수의 타입이 기본데이터 타입인경우. 
   - 객체가 다른 객체의 메서드를 호출할때 단순히 메서드 수행에 필요한 값만 넘기고자 할때, 
 - 호출 되는 메서드의 인자에 복사  해서 받는다
 - 실 매개변수 값은 영향을 안받는다 

### call by reference 
> 참조에 의한 호출 
```java
인스턴스를 넘겼을경우 .

        User user = new User();  
//.. set .. name
//..set .. passowrd 
user.getName() - 하게되면 set한데이터가 넘겨짐 .    
        
user.getpassword() - 하게되면 set 한 password 가 넘겨짐 

//update 메소드를 통해 해당 인스턴스를 넘겨보자 
update(user);



update(User user){
        set ..
        set.. 
        }

그 후 다시 get 을찍어보자 

get Name
get Password 

// 값이 update메서드를 통해서 달라져있다 그 이유 ?
```
- 인스턴스가 생성되면서 힙영역의 객체가 생김
- 그러면서 update메서드에 인자로 해당 인스턴스 값을 넘기게됨 
- 넘겨지게되면서 그 값은힙영역의 객체를 가리키게되면서 그 update메서드안에서 set으로 변경을 했을때 값이 변경되는이유이다. 
- 이것이 call by reference 


## 얕은 복사와 깊은 복사의 차이

### 얕은복사 
> 객체의 참조값, 즉 주소값을 복사하는 것 .
- 새로운 단일 객체 또는 새로운 복합 객체를 만들고 원본 객체를 참조함. 즉  call by reference와 유사한개념.
- 같은 메모리상 영역의 부분을 할당받고싶어하는 영역도 똑같이 바라보고있기때문에 값이 종속적으로 변경이됨 .
### 깊은복사 
> 객체의 실제 값(value) 를 복사한다. 
- 복사하려는 원본객체에 대해서 새로운 단일 객체 또는 새로운 복합 객체를 만들고 원본객체를 대상으로 인스턴스 화할수있는 클래스 내부의 클래스 변수(static) 와 메서드(static) 뿐 아니라 인스턴스 값 모두를 복사하여 원본 객체로부터 독립적인 객체를 생성함 .
- 결국은 각각 다른 메모리 영역을 배정받았기때문에 할당받아서 사용하는 영역은  수정해도 값이 변경이되지안흔ㄴ다. 